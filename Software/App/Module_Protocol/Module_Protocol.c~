/**
  ******************************************************************************
  * @file    Module_Protocol.c
  * @author  Donatello
  * @version V1.0
  * @date    2015.9.16
  * @brief
  ******************************************************************************
  */
/*
*********************************************************************************************************
*                                             INCLUDE FILES
*********************************************************************************************************
*/
#include "Module_Protocol.h"




extern bool		Pile_State_Wait_Flag;
extern uint8_t  Pcak_Pile_State_All_Flag;
extern bool		Pile_State_Open;
extern bool     Can1_Rev_Flag;
extern uint8_t  Can1_Buf[8];
extern OS_EVENT *key;																	//事件控制块 指针
extern OS_EVENT * msg_test;                                                            //按键邮箱事件块指针
extern OS_EVENT * sem_test;                                                            //蜂鸣器信号量指针




/* Public  functions ---------------------------------------------------------*/

/* Private functions ---------------------------------------------------------*/

/*******************************************************************************
  * @函数名称		CheckPack_True_win
  * @函数说明		TRUEWIN移动电源车数据通讯协议
  * @输入参数		无
  * @输出参数		无
  * @返回参数		无
*******************************************************************************/
void    CheckPack_True_win(void)
{
    //预约充电
    //预约取消
    //桩状态查询
    //桩进入非空闲状态
    //桩进入待机模式
    //桩电价查询
    //桩电价修改
    //卡账号信息
    //手机账户余额（待优化）
    //消费信息
    //车辆信息（待优化）
    //充电开始
	Pcak_Pile_State();
    //充电结束
}

/*******************************************************************************
  * @函数名称		CheckPack_Ding_Chong
  * @函数说明		鼎充充电桩数据通讯协议
  * @输入参数		无
  * @输出参数		无
  * @返回参数		无
*******************************************************************************/
void    CheckPack_Ding_Chong(void)
{
	uint8_t* ptr = Can1_Buf;
	uint8_t	 pile_addr;
	uint8_t	 func_code;
    uint8_t pile_state;
    uint16_t

	pile_addr = *ptr++;
	func_code = *ptr++;
	switch(func_code)
	{
		case CTRL_pile_open://01 控制启动
			{
				break;
			}
		case CTRL_pile_close://02 控制停止
			{
				break;
			}
		case READ_pile_info://03(桩信息)0x01 0x03 0x00 0x00 0x00 0x00 0x64 0x66
			{
                ptr+=2;
                pile_state = *ptr++;

				break;
            }
		case READ_card_info://04（卡信息）
			{

				break;
			}
		case READ_consume_info://05（消费信息）
			{
				break;
			}
		case READ_balance_info://06（卡内金额）
			{
				break;
			}
		case READ_time://07（时间）
			{
				break;
			}
		case WRITE_pile_info://10（桩地址、电流、押金）
			{
				break;
			}
		case WRITE_price_info://11（电价）
			{
				break;
			}
		case WRITE_time://12（时间）
			{
				break;
			}
	}
	//OSSemPend
	if(Pile_State_Wait_Flag|Pile_State_Open)
	{
		if(Pcak_Pile_State_All_Flag|Pile_State_Open)
		{
			Pcak_Pile_State_All();
			Pile_State_Wait_Flag = 0;
			Pcak_Pile_State_All_Flag = 0;
		}
	}

}





static const char UART_String1[] = "Usart_Send_Ok\r\n";
/* 串口发送中断回调函数
在函数中写中断想要做的事情
*/
void UART_TX_ISR(uint16_t * byteToSend)
{
    static const char *p = UART_String1;
    *byteToSend = *p++;
    if((p - UART_String1) == sizeof(UART_String1))
    {
        p = UART_String1;
        UART_ITDMAConfig(HW_UART0, kUART_IT_Tx, false);
    }
}
/* 串口接收中断回调函数
   在函数中写中断想要做的事情
*/
void UART_RX_ISR(uint16_t byteReceived)
{
	printf("function:UART_RX_ISR\r\n");
    /* 将接收到的数据发送回去 */
    UART_WriteByte(HW_UART0, byteReceived);
}
/*******************************************************************************
  * @函数名称		CheckPack_Bms
  * @函数说明		Head Address	CID Data length Data Check Tail
  *					0x7E 0x00~0x0e	0x01 ―   ―              ―  0x0D
  * 				信华精机有限公司锂电池BMS通信协议
  * 				1. PC端指令和保护板端指令都遵循此格式
  * 				2. Head为指令头标识符(1byte）
  * 				3. Address为保护板地址码(1byte)
  * 				4. CID为指令序列号(1byte)
  * 				5. Data length为指令长度(1byte)
  * 				6. Data为信息域(不定长，详见下面
  * 				7. Check为校验码字段(1byte,算法见下面)
  * 				8. Tail为指令尾标识符(1byte)
  * @输入参数		无
  * @输出参数		无
  * @返回参数		无
*******************************************************************************/
//void	CheckPack_Bms(void)
//{
//	uint8_t MSK_V_BAL = 0x80;	// 电压平衡标志
//	uint8_t MSK_V_OV  = 0x40;	// 电压过压标志
//	uint8_t MSK_V_UL  = 0x20;	// 电压欠压标志
//	uint16_t for_temp;
//	uint8_t *ptr = ;
//	for(for_temp=0; for_temp<; for_temp++)
//	{
//		//提取均衡标识
//		if((rxbuf[p] &= MSK_V_BAL) > 0)
//		{
//			rxbuf[p] &= ~MSK_V_BAL;
//		}
//		//提取过压标识
//		if((rxbuf[p] &= MSK_V_OV) > 0)
//		{
//			rxbuf[p] &= ~MSK_V_OV;
//		}
//		//提取欠压标识
//		if((rxbuf[p] &= MSK_V_UV) > 0)
//		{
//			rxbuf[p] &= ~MSK_V_UV;
//		}
//	}
//	//保护状态标识符
//	uint16_t MSK_CHG_MOD = 0x01;	//充电模式
//	uint16_t MSK_DISG_MOD = 0x02;	//放电模式
//	uint16_t MSK_SC = 0x04;			//短路保护
//	uint16_t MSK_OC = 0x08;			//过流保护
//	uint16_t MSK_CELL_OV = 0x10;	//单体过压保护
//	uint16_t MSK_CELL_UV = 0x20;	//单体欠压保护
//	uint16_t MSK_CHG_OT = 0x40;		//充过温保护
//	uint16_t MSK_CHG_UT = 0x80;		//充欠温保护
//	uint16_t MSK_DISG_OT = 0x100;	//放电过温
//	uint16_t MSK_DISG_UT = 0x200;	//放电欠温
//	//get protection status
//	if ((Status[1] & o.MSK_CHG_OT) > 0) //充电过温保护
//	{
//		// "充电过温保护"
//	}
//}
void UardDmaFlow(void)
{
	if(Can1_Rev_Flag)
	{
		CheckPack_Ding_Chong();
		Can1_Rev_Flag = false;
	}
}


